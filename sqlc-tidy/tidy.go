package sqlctidy

import (
	"bufio"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/samber/lo"
)

type Organizer struct {
	config  Config
	queries []Query
	workDir string
}

type Query struct {
	name     string
	mode     string
	filepath string
}

func NewOrganizer(dir string) (*Organizer, error) {
	config, err := ReadConfig(dir)
	if err != nil {
		return nil, err
	}
	return &Organizer{config: config, workDir: dir}, nil
}

func (t *Organizer) Run() error {
	// クエリを取得する
	err := t.scanQueries()
	if err != nil {
		return err
	}
	// 自動生成されたファイルのディレクトリを取得する
	genDir := t.autoGeneratedFileDir()
	// 取得したクエリ名の一覧を取得する
	queryNames := lo.Map(t.queries, func(query Query, _ int) string {
		return query.name
	})
	// 取得したクエリ名の一覧の各クエリがコードないで使用されているかチェックする
	usedQueryNames := t.filterUsedQueries(queryNames, genDir)
	// 使用されていないクエリを削除する
	t.deleteUnusedQueries(usedQueryNames)

	return nil
}

// ディレクトリを走査して、クエリを取得する
func (t *Organizer) scanQueries() error {
	queryDir := t.config.SQL[0].Queries
	// ディレクトリを走査して、クエリを取得する
	filepath.Walk(queryDir, func(path string, info os.FileInfo, err error) error {
		// ファイルを開いてクエリ名を取得する
		file, err := os.Open(path)
		if err != nil {
			return fmt.Errorf("cannot open file: %w", err)
		}
		defer file.Close()
		scanner := bufio.NewScanner(file)

		for scanner.Scan() {
			line := scanner.Text()
			if strings.HasPrefix(line, "-- name:") {
				parts := strings.Fields(line)
				if len(parts) >= 3 {
					queryName := parts[2]
					queryMode := strings.TrimPrefix(parts[3], ":")
					t.queries = append(t.queries, Query{name: queryName, mode: queryMode, filepath: path})
				}
			}
		}
		if err != nil {
			return err
		}
		return nil
	})
	return nil
}

func (t *Organizer) isUseQuery(query Query) (bool, error) {
	// 自動生成されたファイルのパスを取得する
	genDir := t.config.SQL[0].Gen.Go.Out
	fmt.Println(genDir)
	return false, nil
}

func (t *Organizer) autoGeneratedFileDir() string {
	return t.config.SQL[0].Gen.Go.Out
}

func (t *Organizer) filterUsedQueries(queryNames []string, ignoreDir string) (UsedQueries []string) {
	filepath.Walk(t.workDir, func(path string, info os.FileInfo, err error) error {
		fmt.Println(path)
		fmt.Println(info.Name())
		// 無視するディレクトリはスキップする
		if strings.HasPrefix(path, ignoreDir) {
			return filepath.SkipDir
		}

		// ファイルセットを作成
		fset := token.NewFileSet()

		// Goファイルを解析
		node, err := parser.ParseFile(fset, info.Name(), nil, parser.AllErrors)
		if err != nil {
			return fmt.Errorf("failed to parse file: %w", err)
		}

		// ASTを巡回して関数呼び出しをチェック
		ast.Inspect(node, func(n ast.Node) bool {
			// 関数呼び出しノードを探す
			if callExpr, ok := n.(*ast.CallExpr); ok {
				// 関数名を取得
				if ident, ok := callExpr.Fun.(*ast.Ident); ok {
					if lo.Contains(queryNames, ident.Name) {
						UsedQueries = append(UsedQueries, ident.Name)
					}
				}
			}
			return true
		})
		return nil
	})
	return UsedQueries
}

func (t *Organizer) deleteUnusedQueries(usedQueryNames []string) {
	for _, query := range t.queries {
		if !lo.Contains(usedQueryNames, query.name) {
			fmt.Println("delete", query.name)
		}
	}
}
