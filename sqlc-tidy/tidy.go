package sqlctidy

import (
	"bufio"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"github.com/samber/lo"
)

type Organizer struct {
	config  Config
	queries []Query
	workDir string
}

type Query struct {
	name     string
	mode     string
	filepath string
}

func NewOrganizer(dir string) (*Organizer, error) {
	config, err := ReadConfig(dir)
	if err != nil {
		return nil, err
	}
	return &Organizer{config: config, workDir: dir}, nil
}

func (t *Organizer) Run() error {
	// クエリを取得する
	err := t.scanQueries()
	if err != nil {
		return err
	}
	// 自動生成されたファイルのディレクトリを取得する
	genDir := t.autoGeneratedFileDir()
	// 取得したクエリ名の一覧を取得する
	queryNames := lo.Map(t.queries, func(query Query, _ int) string {
		return query.name
	})
	// 取得したクエリ名の一覧の各クエリがコードないで使用されているかチェックする
	usedQueryNames, err := t.filterUsedQueries(queryNames, genDir)
	if err != nil {
		return err
	}
	// 使用されていないクエリを削除する
	t.deleteUnusedQueries(usedQueryNames)

	return nil
}

// ディレクトリを走査して、クエリを取得する
func (t *Organizer) scanQueries() error {
	queryDir := t.config.SQL[0].Queries
	// ディレクトリを走査して、クエリを取得する
	filepath.Walk(queryDir, func(path string, info os.FileInfo, err error) error {
		// ファイルを開いてクエリ名を取得する
		file, err := os.Open(path)
		if err != nil {
			return fmt.Errorf("cannot open file: %w", err)
		}
		defer file.Close()
		scanner := bufio.NewScanner(file)

		for scanner.Scan() {
			line := scanner.Text()
			if strings.HasPrefix(line, "-- name:") {
				parts := strings.Fields(line)
				if len(parts) >= 3 {
					queryName := parts[2]
					queryMode := strings.TrimPrefix(parts[3], ":")
					t.queries = append(t.queries, Query{name: queryName, mode: queryMode, filepath: path})
				}
			}
		}
		if err != nil {
			return err
		}
		return nil
	})
	return nil
}

func (t *Organizer) isUseQuery(query Query) (bool, error) {
	// 自動生成されたファイルのパスを取得する
	genDir := t.config.SQL[0].Gen.Go.Out
	fmt.Println(genDir)
	return false, nil
}

func (t *Organizer) autoGeneratedFileDir() string {
	return t.config.SQL[0].Gen.Go.Out
}

func (t *Organizer) filterUsedQueries(queryNames []string, ignoreDir string) (usedQueries []string, err error) {
	if err := filepath.WalkDir(t.workDir, func(path string, info fs.DirEntry, err error) error {
		if err != nil {
			return fmt.Errorf("error accessing path %q: %w", path, err)
		}

		// ディレクトリの場合はスキップする
		if info.IsDir() {
			if strings.HasPrefix(info.Name(), ignoreDir) {
				return filepath.SkipDir
			}
			return nil
		}

		// goファイルでない場合はスキップする
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return fmt.Errorf("failed to parse file %q: %w", path, err)
		}
		ast.Inspect(node, func(n ast.Node) bool {
			if callExpr, ok := n.(*ast.CallExpr); ok {
				var funcName string
				switch fun := callExpr.Fun.(type) {
				case *ast.Ident:
					funcName = fun.Name
				case *ast.SelectorExpr:
					if _, ok := fun.X.(*ast.Ident); ok {
						funcName = fun.Sel.Name
					}
				}
				if lo.Contains(queryNames, funcName) {
					usedQueries = append(usedQueries, funcName)
				}
			}
			return true
		})
		return nil
	}); err != nil {
		return nil, fmt.Errorf("error walking the directory: %w", err)
	}
	return usedQueries, nil
}

func (t *Organizer) deleteUnusedQueries(usedQueryNames []string) {
	for _, query := range t.queries {
		if !lo.Contains(usedQueryNames, query.name) {
			fmt.Printf("==delete==\nfile: %s\nquery: %s\n", query.filepath, query.name)
			query.delete()
		}
	}
}

func (q Query) delete() error {
	// 指定のファイルのクエリを削除する
	// 入力ファイルを開く
	input, err := os.Open(q.filepath)
	if err != nil {
		return fmt.Errorf("ファイルを開けません: %w", err)
	}
	defer input.Close()

	// 一時的な出力ファイルを作成
	output, err := os.Create(q.filepath + ".tmp")
	if err != nil {
		return fmt.Errorf("一時ファイルを作成できません: %w", err)
	}
	defer output.Close()

	scanner := bufio.NewScanner(input)
	writer := bufio.NewWriter(output)
	skipSection := false

	for scanner.Scan() {
		line := scanner.Text()

		if strings.HasPrefix(line, "-- name:") {
			// 新しいセクションの開始
			if strings.Contains(line, q.name) {
				skipSection = true
				continue
			} else {
				skipSection = false
			}
		}

		if !skipSection {
			_, err := writer.WriteString(line + "\n")
			if err != nil {
				return fmt.Errorf("ファイルの書き込みエラー: %w", err)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("ファイルの読み込みエラー: %w", err)
	}

	writer.Flush()

	// 元のファイルを置き換える
	if err := os.Rename(q.filepath+".tmp", q.filepath); err != nil {
		return fmt.Errorf("ファイルの置き換えエラー: %w", err)
	}

	return nil
}
